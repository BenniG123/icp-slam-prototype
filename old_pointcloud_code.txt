		// cv::MatIterator_<uint16_t> it, end;
		// it = data.begin<uint16_t>();
		// end = data.end<uint16_t>();

		// cv::MatIterator_<cv::Vec3b> color_it, color_end;
		// color_it = colorMat.begin<cv::Vec3b>();
		// color_end = colorMat.end<cv::Vec3b>();

		// int p_index = 0;
		int index = 0;

		// int width = data.size().width;

		// float y_prev = 0;
		
		/* while ( it != end) {
			// Blank cells aren't relevant
			// < 4500
			if ((*it) == 0) 
			{
				p_index++;
				color_it++;
				it++;
				continue;
			}

			// Subsample
			if (rand() % 40) {
				p_index++;
				color_it++;
				it++;
				continue;
			}

			float x = (float) (p_index % width);
			float y = (float) (p_index / width);
			float p_z = ((float) (*it)) / 5000;
			float p_x = (x - CX) * p_z / FX;
			float p_y = (y - CX) * p_z / FX;
	      	cv::Point3f p(p_x, p_y, p_z);

	      	cv::Mat colorDepthRotation(3,3,CV_32FC1);
	      	colorDepthRotation = makeRotationMatrix(0.050 * 180.0/PI, -0.062 * 180.0/PI, -0.002 * 180/PI);

			cv::Mat p3d(p);
	      	p3d = colorDepthRotation * p3d;
			p3d.at<float>(0,0) -= 0.02;

	      	cv::Point3f p_c(p3d.at<float>(0,0), p3d.at<float>(1,0), p3d.at<float>(2,0));

	      	int colorX = (int) std::round((p.x * FX / p.z) + CX);
	      	int colorY = (int) std::round((p.y * FY / p.z) + CY);

	      	
	      	// std::cout << colorX << " " << colorY << std::endl;
	      	if (colorX > 640 || colorX < 0 || colorY > 480 || colorY < 0) {
				p_index++;
				it++;
	      		continue;
	      	}

			// P3D' = R.P3D + T
			// P2D_rgb.x = (P3D'.x * fx_rgb / P3D'.z) + cx_rgb
			// P2D_rgb.y = (P3D'.y * fy_rgb / P3D'.z) + cy_rgb

			// Update Center
			center.x += p_x;
			center.y += p_y;
			center.z += p_z;

			// Add point to point cloud
			points.push_back(p);
			colors.push_back(c);

			p_index++; // += SUBSAMPLE_FACTOR;
			index++;
			color_it++;
			it++; // += SUBSAMPLE_FACTOR;
		}

		// std::cout << points.size() << std::endl;
		// std::cout << colors.size() << std::endl;

		/*
		std::vector<cv::Point3f>::iterator itp, endp;
		itp = points.begin();
		endp = points.end();

		while ( itp != endp ) {
			if (rand() % 8) {
				points.erase(itp);
			}
			itp++;
		}
		*/